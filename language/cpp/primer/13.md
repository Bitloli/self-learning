# chapter 13 : 拷贝控制

## question
- [ ] initlize_list 
- [ ] move 的含义
- [ ] 左值右值引用
- [ ] copy constructor 和 copy assignment 的区别 ?
- [ ] copy 和 move 的使用情况举例


## Notes

为了 explicit 或者 implict 的控制一个类的对象的拷贝，移动，赋值，销毁，定义了五个特殊成员函数:
1. copy constructor
2. copy assignment constructor
3. move constructor
4. move assignment constructor
5. destrutor

拷贝构造函数 : 当这个构造函数的第一个参数是自身类的引用，任何额外参数都有默认值
  - [ ] 可以使用多个参数
  - [ ] 额外参数指的是这个构造函数的参数之外的参数吗 ?

- [ ] 我发现我还是无法理解 直接初始化 和 拷贝初始化
  - [ ] https://stackoverflow.com/questions/1051379/is-there-a-difference-between-copy-initialization-and-direct-initialization
  - [ ] 当我们使用的初始化值要求通过 explicit 的构造函数进行类型转换，那么使用拷贝初始化和直接初始化就是无关紧要的了
    - [ ] 442 中间讲解了几个例子，但是和表达的概念关系是什么 ?
  - [ ] 编译器可以略过拷贝初始化和移动初始化函数，但是

- [ ] 拷贝初始化通常使用拷贝构造函数完成，有时候通过移动构造函数完成

需要析构函数的类也需要拷贝和赋值操作

需要拷贝操作的类也需要赋值操作，反之亦然。

- [ ] 既然编译器会帮助我们合成各种函数，为什么需要 =default

析构函数如果被删除, 那么该对象的自动删除功能就消失了，不能定义这种类型的变量或成员，但是可以动态分配这种类型的对象(可以 new 但是无法 delete)。

如果一个类有数据成员不能默认构造，拷贝，复制或者销毁，则对应的成员函数将被定义为删除。

一般来说， 赋值运算符组合了析构函数和拷贝构造函数。

> 注意，是拷贝构造函数，和赋值运算符
> 拷贝构造函数创建了一个新的对象出来
> 赋值运算符是本身就存在一个对象的，需要将其中原来的部分删除掉

> 在赋值运算符中使用 swap 的方法是更加好的，但是实现的前提是正确的实现了拷贝构造函数。因为其中自动发生了一次拷贝构造。

除了性能因素，使用移动的另一个原因是 IO 和 unique_ptr 这种类不能共享资源。

- [ ] move 相关的先找资料，然后到时候重看一次

## move 的其他资料
[如何评价 C++11 的右值引用（Rvalue reference）特性？](https://www.zhihu.com/question/22111546/answer/30801982)

> std::thread的传递
> thread也是一种典型的不可复制的资源，但可以通过移动来传递所有权。同样std::future std::promise std::packaged_task等等这一票多线程类都是不可复制的，也都可以用移动的方式传递。

- [ ] unique_ptr and shared_ptr 's relation ?

- [深入浅出 C++ 11 右值引用](https://zhuanlan.zhihu.com/p/107445960)


```cpp
#include <iostream>
#include <memory>
#include <string>
#include <vector>
using namespace std;

struct RValue {
  RValue() : sources("hello!!!") {}
  RValue(RValue &&a) noexcept {
    sources = std::move(a.sources);
    cout << "&& RValue" << endl;
  }

  RValue(const RValue &a) {
    sources = a.sources;
    cout << "& RValue" << endl;
  }

  void operator=(const RValue &&a) {
    sources = std::move(a.sources);
    cout << "&& ==" << endl;
  }

  void operator=(const RValue &a) {
    sources = a.sources;
    cout << "& ==" << endl;
  }

  string sources;

  ~RValue(){
    cout << "GG\n";
  }
};

vector<RValue> getV(){
  vector<RValue> x(10);
  x.push_back(RValue());
  cout << "----------------\n";
  return x;
}

int main() {
  getV();

	return 0;
}
```

输出如下，可见，由于 push_back 的时候，导致 vector 首先扩张，使用 move constructor 先复制了一次（因为使用的是 noexcept)
然后，作为局部变量的 vector 返回需要拷贝哦（当然拷贝了 vector 的基础诗句）
```
&& RValue
&& RValue
GG
&& RValue
GG
&& RValue
GG
&& RValue
GG
&& RValue
GG
&& RValue
GG
&& RValue
GG
&& RValue
GG
&& RValue
GG
&& RValue
GG
GG
----------------
GG
GG
GG
GG
GG
GG
GG
GG
GG
GG
GG
```

